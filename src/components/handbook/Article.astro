---
import { getCollection, getEntry, render } from 'astro:content';
import { Breadcrumbs } from 'astro-breadcrumbs';
import Sidebar from '@components/handbook/Sidebar.astro';
import PageNav from '@components/handbook/PageNav.astro';
import TableOfContents from '@components/TableOfContents.astro';

import type { MarkdownHeading } from 'astro';
import type { SidebarItems } from '@/src/types/common';

import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';

dayjs.extend(utc);

const handbooks = await getCollection('handbooks', ({ id }) => id !== 'index');
const handbookIndex = await getEntry('handbooks', 'index');

const { articleId: propArticleId, showSidebar = true, class: className } = Astro.props;

// Support both prop-based and URL parameter-based article loading
const urlParam = Astro.url.searchParams.get('article');
const articleId = propArticleId || urlParam || 'index';

let mainArticleEntry;

// Get the specified article for main content display
if (articleId === 'index') {
  mainArticleEntry = handbookIndex;
} else {
  mainArticleEntry = handbooks.find((h) => h.id === articleId);
}

// Render the article content
const mainArticle = mainArticleEntry ? await render(mainArticleEntry) : null;

/**
 * Format last modified date from frontmatter
 */
const lastModified =
  mainArticle && mainArticle?.remarkPluginFrontmatter.updatedDate
    ? mainArticle?.remarkPluginFrontmatter.updatedDate
    : mainArticle?.remarkPluginFrontmatter.lastModified
      ? dayjs(mainArticle.remarkPluginFrontmatter.lastModified).utc().format('MMM DD, YYYY')
      : null;

/**
 * Headings extraction for the main article
 */
const headings: MarkdownHeading[] = mainArticle ? mainArticle.headings : [];

/**
 * Create breadcrumbs manually based on article ID
 * since Astro-Breadcrumbs doesn't support dynamic routes well.
 */
let breadcrumbData = [];
breadcrumbData.push(
  {
    text: 'Home',
    href: '/',
  },
  {
    text: 'Handbook',
    class: 'handbook-menu-toggle',
    href: '/handbook/',
  },
  {
    text: 'Handbook',
    href: '/handbook/',
  }
);

// Extract path segments from article ID
const pathSegments = articleId.split('/').filter(Boolean);

if (pathSegments.length > 0 && pathSegments[0] !== 'index') {
  for (let i = 0; i < pathSegments.length; i++) {
    const segment = pathSegments[i];

    // Skip the last segment as it will be the current page title
    if (i < pathSegments.length - 1) {
      // Format the segment title (capitalize words, replace dashes with spaces)
      const segmentTitle = segment
        .replace(/-/g, ' ')
        .replace(/\b\w/g, (c: string) => c.toUpperCase());

      breadcrumbData.push({
        text: segmentTitle,
        href: '/handbook/' + segment + '/',
      });
    }
  }

  // Add the current page title as the last breadcrumb
  if (mainArticleEntry?.data.title) {
    breadcrumbData.push({
      text: mainArticleEntry.data.title,
    });
  }
} else {
  breadcrumbData = [];
}

/**
 * Build items structure from categories and handbooks data
 * to pass to Sidebar component
 */
const categories = handbookIndex?.data.contents;
let items: {
  [key: string]: SidebarItems;
} = {};

const getCategory = (url: string) => {
  let urlSplit = url.split('/');
  return urlSplit[0];
};

handbooks.forEach((collection) => {
  if (!collection.data.draft) {
    let categorySlug = getCategory(collection.id);

    if (categories) {
      const indexBySlug = categories?.findIndex((cat) => cat.slug === categorySlug);
      if (indexBySlug === -1 || indexBySlug === undefined) {
        console.log(
          'Category:%s not found in list. Available categories:%O',
          categorySlug,
          categories
        );
        return;
      }
      if (items[indexBySlug] && items[indexBySlug].childs) {
        items[indexBySlug].childs.push({
          slug: collection.id,
          label: collection.data.sidebar.label || collection.data.title,
          title: collection.data.title,
          order: collection.data.sidebar.order || 0,
        });
        items[indexBySlug].childs.sort(function (a, b) {
          return a.order - b.order;
        });
      } else {
        try {
          items[indexBySlug] = {
            slug: categories[indexBySlug].slug,
            label: categories[indexBySlug].label,
            childs: [
              {
                slug: collection.id,
                label: collection.data.sidebar.label || collection.data.title,
                title: collection.data.title,
                order: collection.data.sidebar.order || 0,
              },
            ],
          };
        } catch (error) {
          console.log(
            'Error creating category for slug:%s with index:%d',
            categorySlug,
            indexBySlug,
            error
          );
        }
      }
    }
  }
});
---

<section
  class:list={[
    'handbook-article bg-glacier-mist-700 section--block border-glacier-mist-900 z-70 overflow-visible border-b',
    className,
  ]}
  id="handbook-article-container"
>
  <div class="max-width">
    <div class:list={['handbook-container', !showSidebar && 'handbook-container--no-sidebar']}>
      {showSidebar && <Sidebar selectedId={articleId} items={items} />}

      {/* Main Content Area */}
      <article
        class="handbook-content fade-in--pure"
        data-reveal="fade-in--pure--visible"
        data-reveal-immediate="true"
        data-reveal-delay="100"
      >
        <header class="article-header">
          {
            breadcrumbData.length > 0 && (
              <div>
                <Breadcrumbs
                  mainBemClass="c-breadcrumbs"
                  linkTextFormat="sentence"
                  crumbs={breadcrumbData.length > 0 ? breadcrumbData : undefined}
                  customizeLinks={[{ index: 'last', 'aria-disabled': true }]}
                >
                  <svg
                    slot="index"
                    aria-label="Home Page"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"> </path>
                    <polyline points="9 22 9 12 15 12 15 22" />
                  </svg>
                </Breadcrumbs>
              </div>
            )
          }

          <h1 class="article-title">
            {mainArticleEntry?.data.title}
          </h1>
        </header>

        <div class="article-body">
          {
            mainArticle?.Content ? (
              <mainArticle.Content />
            ) : (
              <div class="article-paragraph">
                <p>
                  No content found for article ID: <strong>{articleId}</strong>
                </p>
                {mainArticleEntry ? (
                  <p>Article entry found but content failed to render.</p>
                ) : (
                  <p>
                    Available articles:
                    {Object.values(handbooks).map((handbook) => (
                      <div>
                        <strong>{handbook.data.title}:</strong>{' '}
                        <a href={`/handbook/${handbook.id}`}>{handbook.id}</a>
                      </div>
                    ))}
                  </p>
                )}
              </div>
            )
          }
        </div>

        {/* Navigation */}
        <PageNav
          currentArticleId={articleId}
          categories={categories}
          items={items}
          lastUpdated={lastModified}
        />
      </article>

      <aside class="handbook-toc">
        <TableOfContents headings={headings} title="On This Page" showTitle={true} sticky={true} />
      </aside>
    </div>
  </div>
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const handbookMenuToggle = document.querySelector('.handbook-menu-toggle');

    // Function to toggle sidebar
    const toggleSidebar = () => {
      if (window.innerWidth < 768) {
        const expanded = document.body.hasAttribute('data-aside-menu-expanded');

        if (!expanded) {
          document.body.setAttribute('data-aside-menu-expanded', '');
          document.body.classList.add('handbook-menu-open');
          document.body.style.overflow = 'hidden';
        } else {
          document.body.removeAttribute('data-aside-menu-expanded');
          document.body.classList.remove('handbook-menu-open');
          document.body.style.overflow = '';
        }
      }
    };

    if (handbookMenuToggle) {
      handbookMenuToggle.addEventListener('click', (e) => {
        // Only enable the toggle functionality on mobile screens
        if (window.innerWidth < 768) {
          e.preventDefault();

          // Use the toggle function
          toggleSidebar();
        }
      });

      // Add resize listener to disable toggle functionality on larger screens
      window.addEventListener('resize', () => {
        if (window.innerWidth >= 768) {
          // Ensure mobile menu is closed when resizing to larger screens
          document.body.removeAttribute('data-aside-menu-expanded');
          document.body.classList.remove('handbook-menu-open');
          document.body.style.overflow = '';
        }
      });
    }
  });
</script>
