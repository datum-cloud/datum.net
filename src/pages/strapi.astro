---
// src/pages/strapi.astro
export const prerender = false;

import { Cache } from '@libs/cache';

const STRAPI_URL = import.meta.env.STRAPI_URL || process.env.STRAPI_URL;
const STRAPI_TOKEN = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;
const STRAPI_CACHE_ENABLED =
  import.meta.env.STRAPI_CACHE_ENABLED || process.env.STRAPI_CACHE_ENABLED;
const STRAPI_CACHE_TTL = parseInt(
  import.meta.env.STRAPI_CACHE_TTL || process.env.STRAPI_CACHE_TTL || '0',
  10
);

const cache = new Cache('.cache');
const CACHE_KEY = 'strapi-articles';

interface StrapiArticle {
  documentId: string;
  title: string;
  slug: string;
  description: string;
  originalPublishedAt: string | null;
  createdAt: string;
  updatedAt: string;
  publishedAt: string;
  blocks: StrapiBlock[];
}

type StrapiBlock =
  | { __typename: 'ComponentSharedRichText'; body: string }
  | { __typename: 'ComponentSharedQuote'; title: string; body: string }
  | {
      __typename: 'ComponentSharedMedia';
      file: { url: string; name: string; alternativeText: string | null };
    }
  | {
      __typename: 'ComponentSharedSlider';
      files: { url: string; name: string; alternativeText: string | null }[];
    }
  | { __typename: 'Error'; code: string; message: string | null };

interface StrapiResponse {
  data: {
    articles: StrapiArticle[];
  };
}

async function fetchArticlesFromStrapi(): Promise<StrapiArticle[]> {
  const query = `
    query {
      articles {
          documentId
          title
          slug
          description
          originalPublishedAt
          createdAt
          updatedAt
          publishedAt
          blocks {
            __typename
            ... on ComponentSharedRichText {
              body
            }
            ... on ComponentSharedQuote {
              title
              body
            }
            ... on ComponentSharedMedia {
              file {
                url
                name
                alternativeText
              }
            }
            ... on ComponentSharedSlider {
              files {
                url
                name
                alternativeText
              }
            }
          }
      }
    }
  `;

  const response = await fetch(`${STRAPI_URL}/graphql`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${STRAPI_TOKEN}`,
    },
    body: JSON.stringify({ query }),
  });

  if (!response.ok) {
    const body = await response.text();
    throw new Error(`Strapi API error: ${response.status} ${response.statusText} â€” ${body}`);
  }

  const result: StrapiResponse = await response.json();
  return result.data.articles;
}

let articles: StrapiArticle[] = [];
let error: string | null = null;

try {
  const isCacheEnabled = STRAPI_CACHE_ENABLED === 'true' || STRAPI_CACHE_ENABLED === true;

  if (isCacheEnabled && cache.has(CACHE_KEY)) {
    articles = cache.get<StrapiArticle[]>(CACHE_KEY) || [];
  } else {
    articles = await fetchArticlesFromStrapi();

    if (isCacheEnabled && articles.length > 0) {
      cache.set(CACHE_KEY, articles, STRAPI_CACHE_TTL > 0 ? STRAPI_CACHE_TTL * 1000 : undefined);
    }
  }
} catch (err) {
  error = err instanceof Error ? err.message : 'Unknown error occurred';
}

const output = {
  config: {
    url: STRAPI_URL,
    hasToken: !!STRAPI_TOKEN,
    cacheEnabled: STRAPI_CACHE_ENABLED,
  },
  success: !error,
  cached: cache.has(CACHE_KEY),
  timestamp: new Date().toISOString(),
  count: articles.length,
  error,
  data: articles,
};
---

<pre>{JSON.stringify(output, null, 2)}</pre>
